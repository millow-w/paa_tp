"""
Branch and Bound para Mochila 0-1 com duas restrições (peso e volume)
Implementação corrigida
"""

class BranchAndBound:
    def __init__(self):
        self.melhor_valor = 0
        self.melhor_solucao = []
        self.nos_explorados = 0
        self.nos_podados = 0
    
    def resolver(self, capacidade_peso, capacidade_volume, pesos, volumes, valores):
        """
        Resolve o problema da mochila 0-1 com duas restrições usando Branch and Bound
        """
        n = len(pesos)
        self.melhor_valor = 0
        self.melhor_solucao = [False] * n
        self.nos_explorados = 0
        self.nos_podados = 0
        
        # NO SORTING - usar ordem original para garantir correção do bound
        
        # Iniciar busca
        vetor = [False] * n
        self._backtrack(vetor, 0, n, capacidade_peso, capacidade_volume,
                       pesos, volumes, valores, 0, 0, 0)
        
        return self.melhor_valor, self.melhor_solucao
    
    def _calcular_limitante_superior(self, k, n, capacidade_peso, capacidade_volume,
                                     pesos, volumes, valores, peso_atual, volume_atual, valor_atual):
        """
        Calcula o limitante superior usando relaxação fracionária LINEAR.
        Para cada item, calcula a fração máxima que cabe considerando AMBAS as restrições.
        """
        if k >= n:
            return valor_atual
        
        # Capacidades restantes
        peso_restante = capacidade_peso - peso_atual
        volume_restante = capacidade_volume - volume_atual
        
        limitante = valor_atual
        
        # Adicionar itens restantes (já estão ordenados por densidade)
        for i in range(k, n):
            peso_item = pesos[i]
            volume_item = volumes[i]
            valor_item = valores[i]
            
            if peso_item <= peso_restante and volume_item <= volume_restante:
                # Item cabe completamente
                limitante += valor_item
                peso_restante -= peso_item
                volume_restante -= volume_item
            else:
                # Item não cabe completamente - adicionar fração
                # A fração é limitada pelo recurso mais restritivo
                if peso_item > 0 and volume_item > 0:
                    fracao_peso = peso_restante / peso_item
                    fracao_volume = volume_restante / volume_item
                    # Pegar a menor fração (recurso mais restritivo)
                    fracao = min(1.0, fracao_peso, fracao_volume)
                    limitante += valor_item * fracao
                break  # Não pode adicionar mais nada após item fracionário
        
        return limitante
    
    def _backtrack(self, vetor, k, n, capacidade_peso, capacidade_volume,
                   pesos, volumes, valores, peso_atual, volume_atual, valor_atual):
        """
        Função recursiva de backtracking com poda por limitante superior
        """
        self.nos_explorados += 1
        
        # Caso base: chegou ao fim
        if k == n:
            if valor_atual > self.melhor_valor:
                self.melhor_valor = valor_atual
                self.melhor_solucao = vetor.copy()
            return
        
        # Calcular limitante superior para o nó atual
        limitante = self._calcular_limitante_superior(
            k, n, capacidade_peso, capacidade_volume,
            pesos, volumes, valores, peso_atual, volume_atual, valor_atual
        )
        
        # PODA: Se o limitante não supera o melhor valor, não explore este ramo
        if limitante <= self.melhor_valor:
            self.nos_podados += 1
            return
        
        # Gerar candidatos (ordem: incluir primeiro se possível, depois não incluir)
        candidatos = self._construct_candidates(
            k, peso_atual, volume_atual, pesos, volumes,
            capacidade_peso, capacidade_volume
        )
        
        # Explorar cada candidato
        for incluir in candidatos:
            vetor[k] = incluir
            
            if incluir:
                novo_peso = peso_atual + pesos[k]
                novo_volume = volume_atual + volumes[k]
                novo_valor = valor_atual + valores[k]
            else:
                novo_peso = peso_atual
                novo_volume = volume_atual
                novo_valor = valor_atual
            
            self._backtrack(vetor, k + 1, n, capacidade_peso, capacidade_volume,
                          pesos, volumes, valores, novo_peso, novo_volume, novo_valor)
    
    def _construct_candidates(self, k, peso_atual, volume_atual, pesos, volumes,
                             capacidade_peso, capacidade_volume):
        """
        Constrói lista de candidatos: tenta incluir o item primeiro se ele cabe
        """
        candidatos = []
        
        # Verificar se o item cabe
        if (peso_atual + pesos[k] <= capacidade_peso and 
            volume_atual + volumes[k] <= capacidade_volume):
            # Explorar incluir primeiro (geralmente mais promissor)
            candidatos.append(True)
        
        # Sempre pode não incluir o item
        candidatos.append(False)
        
        return candidatos


def resolver_mochila_bb(capacidade_peso, capacidade_volume, pesos, volumes, valores):
    """
    Função wrapper para resolver o problema da mochila usando Branch and Bound
    
    Args:
        capacidade_peso: Capacidade máxima de peso
        capacidade_volume: Capacidade máxima de volume
        pesos: Lista com peso de cada item
        volumes: Lista com volume de cada item
        valores: Lista com valor de cada item
    
    Returns:
        tuple: (valor_maximo, solucao, estatisticas)
    """
    bb = BranchAndBound()
    valor, solucao = bb.resolver(capacidade_peso, capacidade_volume, pesos, volumes, valores)
    
    estatisticas = {
        'nos_explorados': bb.nos_explorados,
        'nos_podados': bb.nos_podados,
        'taxa_poda': bb.nos_podados / bb.nos_explorados if bb.nos_explorados > 0 else 0
    }
    
    return valor, solucao, estatisticas


# ============================================================================
# EXEMPLO DE USO
# ============================================================================
if __name__ == "__main__":
    # Exemplo do enunciado
    W = 10  # capacidade peso
    V = 9   # capacidade volume
    
    pesos =   [6, 3, 4, 2]
    volumes = [3, 4, 2, 5]
    valores = [10, 14, 16, 9]
    
    print("="*70)
    print("BRANCH AND BOUND - Mochila 0-1 com duas restrições")
    print("="*70)
    print(f"\nCapacidade: Peso={W}, Volume={V}")
    print(f"Número de itens: {len(pesos)}")
    print("\nItens disponíveis:")
    for i in range(len(pesos)):
        print(f"  Item {i}: peso={pesos[i]}, volume={volumes[i]}, valor={valores[i]}")
    
    # Resolver
    valor_max, solucao, stats = resolver_mochila_bb(W, V, pesos, volumes, valores)
    
    # Resultados
    print(f"\n{'='*70}")
    print("RESULTADO")
    print("="*70)
    print(f"Valor máximo: {valor_max}")
    print(f"Itens selecionados: {[i for i in range(len(solucao)) if solucao[i]]}")
    print(f"\nDetalhes dos itens selecionados:")
    
    peso_total = 0
    volume_total = 0
    for i in range(len(solucao)):
        if solucao[i]:
            print(f"  Item {i}: peso={pesos[i]}, volume={volumes[i]}, valor={valores[i]}")
            peso_total += pesos[i]
            volume_total += volumes[i]
    
    print(f"\nPeso total usado: {peso_total}/{W}")
    print(f"Volume total usado: {volume_total}/{V}")
    
    print(f"\n{'='*70}")
    print("ESTATÍSTICAS DO ALGORITMO")
    print("="*70)
    print(f"Nós explorados: {stats['nos_explorados']}")
    print(f"Nós podados: {stats['nos_podados']}")
    print(f"Taxa de poda: {stats['taxa_poda']:.2%}")
    print("="*70)